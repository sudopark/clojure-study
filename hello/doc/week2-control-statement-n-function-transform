
## 제어문과 함수형 변환

- 식(expression): 평가될 수 있는 코드
ex) (first) ; first 함수에 인수가 없기때문에 문법에 맞지 않음
- 형식(form): 평가될 수 있는 적법한 식
ex) (first [1 2 3])


### 논리에 따라 흐름 제어하기
- 어떤 값이 불린 true라는 것을 어떻게 알수 있을까? -> true? 함수
(true? true) ; true
(true? false); false
- false를 검사하는 경우는 -> false?
- 값이 없음을 검사하는 경우 -> nil?
-> 그렇다면 부정은, 어떤것의 반대는 어떻게 검사할까? -> not?
: not 함수는 인수가 논리적으로 거짓이면 true를 반환, 그렇지 않으면 false를 반환
(not true) ; false
(not nil) ; true -> nil은 논리적으로 거짓임
(not "hi") ; false -> 값이 있어도 false

#### 비교 연산자
(= :k :k) ;; true
(= :k 2) ;; false
(= `(1 2 3) [1 2 3]) ; true

(not (= x y)) 표현이 길다면 (not= x y)를 이용

### 컬렉션에 사용하는 논리 검사
empty? -> 벡터와, 리스트, 맵, 집합이 비었는지 확인 가능
(empty? [1 2 3]) ;; false
(empty? []) ;; true

;; empty?의 실제 정의
(defn empty? [coll]
    (not (seq coll)))
여기서 seq는 무엇일까?
-> 클로저에는 콜렉션 추상과, 시퀀스 추상이 있음

- collection
백터, 리스트, 맵 처럼 단순 요소를 모아 놓은 것
clojure.lang.IPersistentCollection 인터페이스를 구현(컬렉션을 추상화한) => 존속적이고 불변적인 자료구조
이를 통해 collection은 count, conj, seq와 같은 함수들을 공유

- sequence
seq 함수는 콜렉션을 시퀀스로 바꾸어 준다. -> 시퀀스 추상은 컬렉션을 리스트처럼 순차적으로 다룰 수 있게 해준다.
시퀀스들도 존속적이고 불변이며 first, rest, cons 함수들을 공유한다.
seq 함수는 컬렉션을 받아 시퀀스를 반환하는데 비어있는 경우 nil을 반환한다.

켈렉션을 처리하는 많은 함수들이 이미 seq로 구현하는 경우가 많아 편리한 경우가 있다 -> first의 경우
하지만 비어있지 않음을 검사하는 경우 (not (empty [])) == (not (not (seq [])))에는 바로 seq를 이용하는 것이 관용적이다.
(seq []) ;; nil

every? 
모든 요소에 대한 검사 결과를 반호ks
(every? predicate collection)
(every? (= 1) [1 2 3]) ;; false
(every? odd? [1 1 3])  ;; true

(defn drinkable? [x]
    (= x :drinkme))
(every? drinkable? [:drinkme :drinkme]) ;; true
(every? #(= % :drinkme) [:drinkme :drinkme]) ;; true

not-any?
모든 요소가 거짓인 경우
(not-any? #(= % 1) [1 2 3]) ;; false
(not-any? #(= % 1) [2 3 4]) ;; true

some
진위 함수가 평가한 값이 처음으로 논리적으로 참일때 그 평가한 값을 반환하고 아니면 nil을 반환한다.
(some #(> % 3) [1 2 3 4]) ;; 4

시퀀스에 요소가 있는지 확인할때 집합을 진위 함소로 사용하면 매우 편리하다.
진위 함수가 반환한 값이 nil이나 false가 아니면 논리적으로 참으로 취급되는것을 기억하자, 또한 집합은 요소의 존재 여부를 확인할 수 있는 함수로 사용될 수 있다.
(#{1 2 3} 1) ;; true
(some #{1} [1 2 3 4 5]) ;; 1
(some #{4 5} [1 2 3 4 5]) ;; 4
하지만 논리적으로 거짓인 값에 대해서는 조심해야 한다.
(some #{nil} [nil nil nil]) ;; nil
(some #{false} [false false false]) ;; nil


### 흐름제어 이용하기

if
(if true 1 2) ;; 1
(if false 1 2) ;; 2
(if nil 1 2) ;; 2
(if (= :k :k) 1 2) ;; 1

if-let
if-let은 식을 평가한 결과를 심볼에 바인딩한 후 만약 그 결과가 논리적으로 참이라면 첫번째 인수를 평가하고, 아니면 마지막 인수를 평가한다.
이것은 let을 잠시 쓰고 다음에 if를 쓰는 것보다 더 간결하다.
(let [need-to-grow-small (> 5 3)]
    (if need-to-grow-small 1 2))
;; 1
(if-let [need-to-grow-small (> 5 3)]
    1 2)
;; 1

when
결과가 참일 경우만 처리하고 싶을때, 참일 경우만 본문을 평가한다. 참이 아니면 nil을 반환한다.
(defn drink [need-to-grow-small]
    (when need-to-grow-small "drink bottle"))
(drink true) ;; "drink bottle"
(drink false) ;; nil

when-let
논리검사 결과를 심볼에 바인딩하고, 참이면 본문을 평가하고 아니면 nil을 반환
(when-let [need-to-grow-small] "drink bottle")
; "drink bottle"

cond
조던식을 여러개 쓰고 싶은 경우
cond식은 검사식과 그 검사식이 참일 때 평가될 식의 쌍들을 받는다.
-> 다른 언어의 if/else-if 구문과 비슷함
(let [bottle "drink me"]
    (cond 
        (= bottle "poison") "dont touch"
        (= bottle "drink me") "drink"
        (= bottle "empty") "all gone"))
; "drink"
cond 절에서는 한 검사가 참이면 해당 식이 평가되고 나머지는 무시되기 때문에 순서가 중요하다.

(let [x 5]
    (cond 
        (> x 10) "bigger than 10"
        (> x 4) "bigger than 4"
        (> x 3) "bigger than 3"))
;; "bigger than 4"
(let [x 5]
    (cond 
        (> x 10) "bigger than 10"
        (> x 3) "bigger than 3"
        (> x 4) "bigger than 4"))
;; "bigger than 3"
어떤 검사식도 참이 아니라면 nil이 반환된다.

디폴트절을 넣고 싶으면 맨 마지막에 :else 키워드를 넣는다 -> if/else와 같음
-> :else는 논리적으로 참으로 평가됨 => 고로 참으로 평가되는 아마 문자열이 들어가도 상관없음
(let [x 0]
    (cond 
        (> x 10) "bigger than 10"
        (> x 3) "bigger than 3"
        (> x 4) "bigger than 4"
        :else "some"))
; "some"

cond 검사식ㅇ ㅣ같은 심볼을 반복적으로 검사한다면 좀 더 간결한 식을 사용할 수 있음
검사할 심볼이 같고 그 값을 =로 비교할 수 있는 경우에는 cond 대신에 단축형인 case를 사용할 수 있다.
(let [bottle "drinkme"]
    (case bottle
        "posion" "1"
        "drinkme" "2"
        "empty" "3"))
; "2"

하지만 만약 참인 경우가 없다면 case는 cond와 다르게 동작한다. 참이 없는 경우에 nil을 반환하는 cond와는 달리 case는 참인 절이 없다는 예외를 던진다.
case에 기본값을 제공하려면 맨 마지막에 하나의 식을 주면 되는데, 참인 경우가 하나도 없을 때 이 식이 평가된다,
(let [bottle "dont drinkme"]
    (case bottle
        "posion" "1"
        "drinkme" "2"
        "empty" "3"
        "unknown"))
;; unknown