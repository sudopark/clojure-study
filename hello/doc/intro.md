# Introduction to hello

TODO: write [great documentation](http://jacobian.org/writing/what-to-write/)


### leiningen 프로젝트 관리툴 사용하기
: leiningen 은 클로저의 프로젝트 관리 툴

### 실행
lein run 

### 설치
closure는 jvm에서 돌아가기때문에 Closure 코드를 class 파일로 컴파일해서 java로 실행 가능

### 실행
lein run 명령어로 파일을 실행
-m 옵션의 인자로 네임스페이스를 지정해주면됨
```
$lein run -m hello.core
```

#### 컴파일해서 java로 실행하기
lein complie 명령어로 컴파일 할 수 있음
```
$lein complie hello.core
```
컴파일이되면 target/classes 디렉토리 아래 클래스 파일이 생성된다.

#### 실행하기
closure는 namespace 단위로 class를 만들지 않고 function 단위로 class를 만든다. java로 class를 실행하기 위해서는 자바 main 함수가 있는 클래스를 만들어야함.
네임스페이스를 클래스로 만드려면 ns 구문에 :gen-class 라는 지시문을 넣어주면 된다(그냥 실행할때 이 지시어가 없는 이유는 클래스를 생성하지 않고 동적으로 evaluation 하기 때문)




## 클로저의 구조
클로저 코드는 식으로 구성되며 그 식이 평가된 결과가 반환된다. 이들 중 가장 단순한 것은 자기 자신으로 평가되는 것이다.
이러한 식을 단순값(simple value) 혹은 리터럴(literal)이라 부른다.

### 단순값으로 처음 시작하기
분수가 평가죌때는 실수로 변환되지 않음 -> 4/5
산술연산을 하려면 괄호로 둘러싼 더 큰 식이 필요하다. -> (/ 1 3) => 1/3

클로저가 다른 언어와 다른점은 괄호이다, 그리고 또다른 점은 연산자가 먼저 나온다는 점이다.

클로저에서 키워드는 :로 시작하는 식별자이다. 역시 키워드는 단순 값이다.


### 클로저 데이터를 데이터 컬렉션에 담기
클로저에서 데이터를 담을 수 있는 컬렉션은 여러 종류가 있다. 리스트, 벡터, 맵, 집합이 바로 그것이다.

##### 리스트 컬렉션 사용하기
- 요소들이 순서가 있음
- 괄호 앞에 '을 붙이고 데이터를 괄호안에 넣으면 된다. => '(1 2 3 "1" :key)
- 리스크 안에 여러 종류의 값을 담아도 상관없음, 또한 중간에 쉼표를 넣어도 상관없음(공백문자처럼 간주됨) -> 관용적이지는 않은 방법

리스크는 다음과 같이 두가지 부분으로 구성되어있다 생각할수있다 => 리스트의 첫 요소 + 나머지 부분
(first '(1 2 3)) => 1
(rest '(1 2 3)) => (2 3)
rest를 계속 사용해서 리스트의 마지막에 다다르면 nil을 만나게 된다. -> 이경우 리스트의 끝을 의미한다.

cons 함수는 두개의 인수를 받는다. 첫째는 추가하고자하는 요소이고 둘때는 요소가 추가될 리스트이다.
그래서 빈 리스트에 무언가를 추가하려면
(cons 4 '()) => (4)

nil은 리스트의 끝을 의미하기 때문에 다음과같이 할수도있다
(cons 4 nil) => (4)

리스트의 첫번째 요소 말고 중간에 있는 요소를 접근하고자할때는 어떻게 해야할까? 다른말로 인덱스 접근이 필요한 경우 말이다.
이럴때는 벡터가 필요하다.

#### 백테를 사용해 인덱스로 데이터 접근하기
- 벡터는 대괄호로 둘러싸서 만든다. -> [1 2 3]
- 벡터도 first, rest 연산자가 존재한다.
- nth 함수를 이용하여 벡터에 있는 요소에 접근할 수 있다 -> (nth [1 2 3] 1) => 2

리스트도 벡터처럼 nth, last를 이용할 수 있지만 퍼포먼스가 좋지않다(처음부터 순회하며 요소를 찾음)

#### 컬렉션의 공통점들
콜렉션은 불변이고 존속적이다(persistant) 불변이란 콜렉션의 값이 변하지 않음을 뜻한다. 컬렉션의 요소를 cons로 요청하게 되면, 원래의 컬렉션은 변하지 않는다.
단지 그 요소가 추가된 새로운 버전의 콜렉션이 만들어진다.
존속이란 구조공유(structal sharing)이라는 기법을 이용하여 컬렉션의 신규 버전을 효율적으로 만드는것을 뜻한다.

conj함수는 컬렉션에 하나 이상의 원소를 추가한다. 하지만 그 콜렉션의 구조에 가장 효율적인 방식으로 추가한다.
벡터의 경우에는 맨 마지막에 요소를 추가하고 리스트의 경우에는 맨 앞에 추가한디.

#### 맵을 이용해서 키-값 쌍의 데이터를 저장하기
맵은 키-값 쌍으로 된 데이터를 저장하는데 유용하다.
{:id 1 :name "some"}

get 함수를 이용하여 맵에서 값을 가져올 수 있다.
(get {:id 1 :name "some"} :id) => 1
키가 없는 경우에는 디폴트값을 줄수도 있다
(get {:id 1 :name "some"} :level 30) => 30

맵의 키값을 이용하여 get 없이 값을 읽어오는 경우도 있다. 이 경우 키 자체를 함수로 사용한다.
키워드는 맵에서 키로 자주 사용되는 자료형이다.
(:name {:id 1 :name "some"}) => "some"
(키워드를 사용하는것이 더 관용적이기는함)

keys함수는 맵의 키값만을, vals는 값들만 불러온다.

맵의 값을 갱신 하려면 어떻게 해야할까? -> 클로저에서 이는 새로운 값을 지니는 새로운 콜렉션이 반환됨을 의미
assoc 함수는 맵에 새로운 키-값 쌍을 결합한다.
(assoc {:id 1 :name "some"} :level 3)

(dissoc) 함수는 맵과 키를 인수로 받아 관련된 키-값 쌍을 제거한다
(dissoc {:id 1 :name "some"} :id)

merge 함수는 맵을 합칠때 사용한다.
(merge {:id 1 :name "some"}
        {:level 1}
        {:grade "some"})

#### 집합을 이용해 유일한 데이터의 켈렉션 표현하기
짖ㅂ합은 중복이 없는 컬렉션을 사용할때 사용한다.
#{:red :white :black}

집합이기 때문에 합집합(union), 차집합(difference), 교집합(intersection)과 같은 집합 연산이 가능하다.
이것들을 사용하기 위해서는 closure.set을 앞에 붙여주어야 한다.
(closure.set/union #{1 2 3} #{4 5 5}) => #{1 2 3 4 5 6}
(closure.set/difference #{1 2 3} #{1}) => #{2 3}
(closure.set/intersection #{1 2 3} #{2 3}) => #{2 3}

set 함수를 사용하여 다른 종류의 콜렉션을 집합으로 바꿀 수 있다.
맵 또한 가능하다. 이때 키-쌍은 벡터로 변환되어 집합의 요소가 된다.
(set [1 1 2 3]) => #{1 2 3}
(set {:id 1 :name "some"}) => #{[:id 1] [:name "some"]}

집합에서 요소를 찾으려면 get 함수를 이용하면 된다. 키워드를 사용하는 경우도 가능하다. 없으면 nil이 반환된다.

집합 자체를 함수로 사용할 수 있다.
(#{1 2 3} 1} => 1
집합에 요소가 있는지 확인하기 위한 다른 방법으로는 contains?가 있다. 
(contains? #{1 2 3} 1) => true

집합에 요소를 추가하려면 conj 함수를 이용한다.
(conj #{1 2 3} 4) => #{1 2 3 4}

disj 함수는 요소들을 제거할때 사용한다.
(disj #{1 2 3} 1) => #{2 3}


### 리스트는 클로저의 핵심이다
클로저의 기본 데이터 구조인 리스트는 LISP 언어의 본질에서 매우 유래한다. 사실 LISP이라는 이름은 LISt Processing에서 온 것이다.
'(1 2 3)
리스트의 맨앞에 오는 인용구는 리스틀 만드는데 쓴다. 왜 이 기호가 필요할까?
LISP에서는 식(expression)의 첫 요소를 연산자나 함수로 인식하기 때문이다. 그 다음 요소는 모두 연산자나 인수로 인식된다.

그러면 덧셈 연산앞에 '를 붙이면 어떻게 될까?
'(+ 1 1) => (+ 1 1)
클러저는 이것을 3개의 요소를 지니는 리스트로 인식을 한다.
- 첫째 요소는 연산자이며
- 두번째, 새번째는 정수 1이다.
(first '(+ 1 1)) => +

코드가 데이터로 취급된다 -> 모든 클러저 코드는 데이터의 리스트로 구성되어있다.


### 심볼과 바인딩의 기술
: 클로저의 심볼은 값을 가르키고, 그 심볼이 평가되면 가르키는 값을 반환한다.
def: def는 값에 이름을 줘서 나중에 다른곳에서도 이를 참조할수있게하낟.
def는 심볼에 값을 직접 바인딩하지않고 var를 통해서 한다.
Var는 다른 언어의 변수와는 같지 않은데 바뀌지않기때문이다.
(def developer 'Alice' )
-> def는 REPL의 디폴트 이름공간인 user에 심볼인 developer를 위한 var 객체를 만들어낸다. -> REPL이 developer를 평가하면 "Alice"라는 값으로 편가된다.

심볼 앞에 /를 붙여서 이름공간을 지정할 수 있다.
user/developer


#### 전역적이지 않은 Var 혹은 임시으 Var -> let
let을 사용하면 let 영역 안에서만 사용되는 심볼에 값을 바인딩 할 수 있다.
(def developer "Alice")  ;; #'user/developer
(let [developer "Alice in let"])   ;; "Alice in let"
developer   ;; "Alice"

let 바인딩은 벡터 안에 심볼과 값의 쌍들로 구성된다.


### 함수 만들기
우리는 함수를 반들고 그것을 심볼에 할당하고 나중에 그 함수를 호출할 수 있다.

defn는 def와 비슷하지만 함수를 위한 var을 만든다. defn은 함수 이름, 인수들의 벡터, 함수 본문을 인수로 받는다.
함수가 호출되면 클로저는 그 함수를 평가한 후 결과를 반환한다.
빈 벡터를 이용하면 함수를 인수 없이 정의할수도있다.
(defn foo [] "bar")
(foo)  ;; "bar"

(defn foo [k1 k2]
  {:k1 k1
  :k2 k2})
(foo 1 2)


#### 무명함수
무명함수는 fn으로 만든다. 
(fn [] "foo")
((fn [] "foo")) ;; "foo"

사실 defn은 def로 무명 함수에 이름을 바인딩하는것과 동일하다.
(def foo-again (fn [] ("foo")))
foo-again  ;; "foo"

무명함수를 만드는 단축형도 있다. 괄호 앞에 #를 붙이면 된다.
(#("foo"))
만약 인수가 있다면 퍼센트 기호로 나타낼 수 있다.
(#(str "foo" %) "!") ;; "foo!"

이제 모든 종류의 심볼을 만드는 법에 대하여 알아봤다. 
객체지향 언어에서는 비슷한 함수들을 묶어서 담는 객체를 사용한다 <-> 클로저는 이름공간이라는 다른 방법을 사용한다.

#### 이름공간에서 심볼 관리하기
이름 공간은 var에 대한 접근을 조직하고 제어하는 방법이다.
def와 defn으로 var를 만들때 user라는 REPL의 디폴트 이름공간에서 var를 생성하는것을 보았다.
ns를 사용하면 이름공간을 새로 만들고, 그 이름공간으로 전환할 수 있다.

(ns alice.favFoods ;; nil
이 시점에서 REPL의 현재 이름공간은 디폴트 이름공간에서 새롭게 정의한 alice.favFoods로 바뀌었다.
*ns*가 반환화는 값을 보면 이를 확인할 수 있다.
양쪽의 * 표시는 귀마개 표시라고 부르는데 다시 바인딩 할 수 있는것을 표시하는 관례이다.

(def foo "bar")
;; alice.favFoods/foo에 있음

다른 공간으로 전환하면 그 심볼은 더이상 참조되지 않느다.

클로저 라이브러리들은 이름공간과 그 이름공간의 심볼들로 구성된다.
require를 이용하여 자신의 이름공간에서 라이브러리를 사용할 수 있는 세가지 방법이 있다.
1. 이름공간을 인수로 받아 require를 사용하는것 -> 그러면 라이브러리가 로딩되고 완전한 이름으로 접근할 수 있다.
앞에 set 함수를 사용했을 때 완전한 이름을 사용해야 했다. clojure.set/union의 예를 보자
;; 합잡합 구하기
(clojure.set/union #{1 2 3} #{2 3 4}) ;; #{2 3}

clojure.set 이름공간은 REPL이 시작될때 로딩된다. 그렇지 않은 경우 require를 사용해서 그 작업을 직접 할 수 있다.
(require 'clojure.set)

2. 두번째 방법으s :as 를 사용해서 require의 별칭(alias) 기능을 이용하는 것이다.
(ns some_namespace) ;; => nil
(require '[alice.favFoods : as af])
af/foo ;; "foo"

(ns some_namespace
  (:require [alice.favFoods :as af]))
  af/foo ;; "foo"

3. require를 이름공간, :refer, :all 옵션과 함께 사용할 수 있다.
이러면 그 이름공간의 모든 심볼이 로딩되고 현재의 이름공간에서 심볼 이름만으로 직접 접근할 수 있다. -> 이름 충돌이 일어날 수 있어 약간 위험함
또한 함수가 어떤 라이브러리에서 왔는지 파악 힘듬

다른 네임스페이스에서 favFoods의 foo를 접근하려면 어떻게 해야할까
(ns some_namespace
  (:require [alice.favFoods :refer :all]
            [rabit.favFoods :refer :all]))

대부분의 클로저 코드는 require로 라이브러리를 사용하고 :as 로 별칭을 지정한다.
예외가 될 수 있는 것은 테스트 코드를 작성할 때 인데, 이럴때는 테스트하려는 이름공간과 clojure.set의 함수들을 직접 사용하는 것이 일반적이다.

use 함수는 require를 :refer :all과 함께 쓰는것과 같다.(:refer :all이 더 좋음)

예제 - 유저 a, b가 좋아하는 수를 받아 공통으로 좋아하는 수를 출력
(ns example
 (:require clojure.set :as s))

(defn common-fav-numbers [ns1, ns2]
  (let [ns-set1 (set ns1)
        ns-set2 (set ns2)
        common (s/intersection ns-set1 ns-set2)]
   (str "common numbers: " common)))

(common-fav-numbers [1 2 3] [2 3 4]) ;; "common numbers #{2 3}"