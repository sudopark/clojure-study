# Introduction to hello

TODO: write [great documentation](http://jacobian.org/writing/what-to-write/)


### leiningen 프로젝트 관리툴 사용하기
: leiningen 은 클로저의 프로젝트 관리 툴

### 실행
lein run 

### 설치
closure는 jvm에서 돌아가기때문에 Closure 코드를 class 파일로 컴파일해서 java로 실행 가능

### 실행
lein run 명령어로 파일을 실행
-m 옵션의 인자로 네임스페이스를 지정해주면됨
```
$lein run -m hello.core
```

#### 컴파일해서 java로 실행하기
lein complie 명령어로 컴파일 할 수 있음
```
$lein complie hello.core
```
컴파일이되면 target/classes 디렉토리 아래 클래스 파일이 생성된다.

#### 실행하기
closure는 namespace 단위로 class를 만들지 않고 function 단위로 class를 만든다. java로 class를 실행하기 위해서는 자바 main 함수가 있는 클래스를 만들어야함.
네임스페이스를 클래스로 만드려면 ns 구문에 :gen-class 라는 지시문을 넣어주면 된다(그냥 실행할때 이 지시어가 없는 이유는 클래스를 생성하지 않고 동적으로 evaluation 하기 때문)




## 클로저의 구조
클로저 코드는 식으로 구성되며 그 식이 평가된 결과가 반환된다. 이들 중 가장 단순한 것은 자기 자신으로 평가되는 것이다.
이러한 식을 단순값(simple value) 혹은 리터럴(literal)이라 부른다.

### 단순값으로 처음 시작하기
분수가 평가죌때는 실수로 변환되지 않음 -> 4/5
산술연산을 하려면 괄호로 둘러싼 더 큰 식이 필요하다. -> (/ 1 3) => 1/3

클로저가 다른 언어와 다른점은 괄호이다, 그리고 또다른 점은 연산자가 먼저 나온다는 점이다.

클로저에서 키워드는 :로 시작하는 식별자이다. 역시 키워드는 단순 값이다.


### 클로저 데이터를 데이터 컬렉션에 담기
클로저에서 데이터를 담을 수 있는 컬렉션은 여러 종류가 있다. 리스트, 벡터, 맵, 집합이 바로 그것이다.

##### 리스트 컬렉션 사용하기
- 요소들이 순서가 있음
- 괄호 앞에 '을 붙이고 데이터를 괄호안에 넣으면 된다. => '(1 2 3 "1" :key)
- 리스크 안에 여러 종류의 값을 담아도 상관없음, 또한 중간에 쉼표를 넣어도 상관없음(공백문자처럼 간주됨) -> 관용적이지는 않은 방법

리스크는 다음과 같이 두가지 부분으로 구성되어있다 생각할수있다 => 리스트의 첫 요소 + 나머지 부분
(first '(1 2 3)) => 1
(rest '(1 2 3)) => (2 3)
rest를 계속 사용해서 리스트의 마지막에 다다르면 nil을 만나게 된다. -> 이경우 리스트의 끝을 의미한다.

cons 함수는 두개의 인수를 받는다. 첫째는 추가하고자하는 요소이고 둘때는 요소가 추가될 리스트이다.
그래서 빈 리스트에 무언가를 추가하려면
(cons 4 '()) => (4)

nil은 리스트의 끝을 의미하기 때문에 다음과같이 할수도있다
(cons 4 nil) => (4)

리스트의 첫번째 요소 말고 중간에 있는 요소를 접근하고자할때는 어떻게 해야할까? 다른말로 인덱스 접근이 필요한 경우 말이다.
이럴때는 벡터가 필요하다.

#### 백테를 사용해 인덱스로 데이터 접근하기
- 벡터는 대괄호로 둘러싸서 만든다. -> [1 2 3]
- 벡터도 first, rest 연산자가 존재한다.
- nth 함수를 이용하여 벡터에 있는 요소에 접근할 수 있다 -> (nth [1 2 3] 1) => 2

리스트도 벡터처럼 nth, last를 이용할 수 있지만 퍼포먼스가 좋지않다(처음부터 순회하며 요소를 찾음)

#### 컬렉션의 공통점들
콜렉션은 불변이고 존속적이다(persistant) 불변이란 콜렉션의 값이 변하지 않음을 뜻한다. 컬렉션의 요소를 cons로 요청하게 되면, 원래의 컬렉션은 변하지 않는다.
단지 그 요소가 추가된 새로운 버전의 콜렉션이 만들어진다.
존속이란 구조공유(structal sharing)이라는 기법을 이용하여 컬렉션의 신규 버전을 효율적으로 만드는것을 뜻한다.

conj함수는 컬렉션에 하나 이상의 원소를 추가한다. 하지만 그 콜렉션의 구조에 가장 효율적인 방식으로 추가한다.
벡터의 경우에는 맨 마지막에 요소를 추가하고 리스트의 경우에는 맨 앞에 추가한디.

#### 맵을 이용해서 키-값 쌍의 데이터를 저장하기
맵은 키-값 쌍으로 된 데이터를 저장하는데 유용하다.
{:id 1 :name "some"}

get 함수를 이용하여 맵에서 값을 가져올 수 있다.
(get {:id 1 :name "some"} :id) => 1
키가 없는 경우에는 디폴트값을 줄수도 있다
(get {:id 1 :name "some"} :level 30) => 30

맵의 키값을 이용하여 get 없이 값을 읽어오는 경우도 있다. 이 경우 키 자체를 함수로 사용한다.
키워드는 맵에서 키로 자주 사용되는 자료형이다.
(:name {:id 1 :name "some"}) => "some"
(키워드를 사용하는것이 더 관용적이기는함)

keys함수는 맵의 키값만을, vals는 값들만 불러온다.

맵의 값을 갱신 하려면 어떻게 해야할까? -> 클로저에서 이는 새로운 값을 지니는 새로운 콜렉션이 반환됨을 의미
assoc 함수는 맵에 새로운 키-값 쌍을 결합한다.
(assoc {:id 1 :name "some"} :level 3)

(dissoc) 함수는 맵과 키를 인수로 받아 관련된 키-값 쌍을 제거한다
(dissoc {:id 1 :name "some"} :id)

merge 함수는 맵을 합칠때 사용한다.
(merge {:id 1 :name "some"}
        {:level 1}
        {:grade "some"})

#### 집합을 이용해 유일한 데이터의 켈렉션 표현하기
짖ㅂ합은 중복이 없는 컬렉션을 사용할때 사용한다.
#{:red :white :black}

집합이기 때문에 합집합(union), 차집합(difference), 교집합(intersection)과 같은 집합 연산이 가능하다.
이것들을 사용하기 위해서는 closure.set을 앞에 붙여주어야 한다.
(closure.set/union #{1 2 3} #{4 5 5}) => #{1 2 3 4 5 6}
(closure.set/difference #{1 2 3} #{1}) => #{2 3}
(closure.set/intersection #{1 2 3} #{2 3}) => #{2 3}

set 함수를 사용하여 다른 종류의 콜렉션을 집합으로 바꿀 수 있다.
맵 또한 가능하다. 이때 키-쌍은 벡터로 변환되어 집합의 요소가 된다.
(set [1 1 2 3]) => #{1 2 3}
(set {:id 1 :name "some"}) => #{[:id 1] [:name "some"]}

집합에서 요소를 찾으려면 get 함수를 이용하면 된다. 키워드를 사용하는 경우도 가능하다. 없으면 nil이 반환된다.

집합 자체를 함수로 사용할 수 있다.
(#{1 2 3} 1} => 1
집합에 요소가 있는지 확인하기 위한 다른 방법으로는 contains?가 있다. 
(contains? #{1 2 3} 1) => true

집합에 요소를 추가하려면 conj 함수를 이용한다.
(conj #{1 2 3} 4) => #{1 2 3 4}

disj 함수는 요소들을 제거할때 사용한다.
(disj #{1 2 3} 1) => #{2 3}


### 리스트는 크로저의 핵심이다
클로저의 기본 데이터 구조인 리스트는 LISP 언어의 본질에서 매우 유래한다. 사실 LISP이라는 이름은 LISt Processing에서 온 것이다.
'(1 2 3)
리스트의 맨앞에 오는 인용구는 리스틀 만드는데 쓴다. 왜 이 기호가 필요할까?
LISP에서는 식(expression)의 첫 요소를 연산자나 함수로 인식하기 때문이다. 그 다음 요소는 모두 연산자나 인수로 인식된다.

그러면 덧셈 연산앞에 '를 붙이면 어떻게 될까?
'(+ 1 1) => (+ 1 1)
클러저는 이것을 3개의 요소를 지니는 리스트로 인식을 한다.
- 첫째 요소는 연산자이며
- 두번째, 새번째는 정수 1이다.
(first '(+ 1 1)) => +

코드가 데이터로 취급된다 -> 모든 클러저 코드는 데이터의 리스트로 구성되어있다.


